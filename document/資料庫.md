# 資料庫設計

### 1\. PostgreSQL 資料庫設計

根據系統描述，PostgreSQL 負責儲存**使用者資料**與**對話紀錄**。這類結構化資料非常適合使用關聯式資料庫。我將其設計為三個核心資料表：`users`, `conversations`, 和 `messages`。

#### `使用者 (users)`

此資料表儲存應用程式的使用者基本資料。主要由 **Web App** 進行讀寫。

| 欄位名稱 | 資料型態 | 限制/說明 |
| :--- | :--- | :--- |
| `id` | `UUID` | **PK**, `default gen_random_uuid()` |
| `email` | `VARCHAR(255)` | `NOT NULL`, `UNIQUE`. 用於登入和識別。建議建立索引。 |
| `hashed_password` | `VARCHAR(255)` | `NOT NULL`. 儲存雜湊後的密碼。 |
| `full_name` | `VARCHAR(100)` | 使用者全名。 |
| `created_at` | `TIMESTAMPTZ` | `NOT NULL`, `default now()` |
| `updated_at` | `TIMESTAMPTZ` | `NOT NULL`, `default now()` |

-----

#### `對話 (conversations)`

此資料表用於組織多次的對話，代表一個完整的對話主題或會話 (Session)。主要由 **AI Worker** 寫入。

| 欄位名稱 | 資料型態 | 限制/說明 |
| :--- | :--- | :--- |
| `id` | `UUID` | **PK**, `default gen_random_uuid()` |
| `user_id` | `UUID` | **FK** -\> `users(id)`, `NOT NULL`. 標示此對話屬於哪個使用者。建議建立索引。 |
| `title` | `VARCHAR(255)`| `NOT NULL`. 對話標題，可由第一個問題或 LLM 生成的摘要產生。 |
| `created_at` | `TIMESTAMPTZ` | `NOT NULL`, `default now()` |
| `updated_at` | `TIMESTAMPTZ` | `NOT NULL`, `default now()` |

-----

#### `訊息 (messages)`

此資料表儲存每一則使用者與 AI 之間的問答訊息。這是最核心的對話紀錄。在新的架構中，主要由 **Web App** 在收到 `results.queue` 的訊息後寫入。

| 欄位名稱 | 資料型態 | 限制/說明 |
| :--- | :--- | :--- |
| `id` | `UUID` | **PK**, `default gen_random_uuid()` |
| `conversation_id` | `UUID` | **FK** -\> `conversations(id)`, `NOT NULL`. 標示此訊息屬於哪個對話。建議建立索引。 |
| `sender_type` | `VARCHAR(10)` | `NOT NULL`. 標示發送者，例如 `'USER'` 或 `'AI'`。 |
| `text_content` | `TEXT` | 訊息的文字內容 (STT 轉譯結果或 LLM 回應)。 |
| `audio_input_url` | `TEXT` | (可選) 使用者上傳的原始語音檔案儲存位置 (例如 S3 URL)。 |
| `audio_output_url`| `TEXT` | (可選) TTS 生成的語音檔案儲存位置 (例如 S3 URL)。 |
| `task_id` | `UUID` | (可選) 關聯到觸發此訊息生成的非同步任務 ID，便於追蹤與除錯。 |
| `created_at` | `TIMESTAMPTZ` | `NOT NULL`, `default now()` |

-----

#### 表間關聯 (Relationships)

```
[users] 1 -- * [conversations] 1 -- * [messages]
```

  - 一個 **`user`** 可以擁有多個 (many) **`conversations`**。
  - 一個 **`conversation`** 只能屬於一個 (one) **`user`**。
  - 一個 **`conversation`** 可以包含多個 (many) **`messages`**。
  - 一個 **`message`** 只能屬於一個 (one) **`conversation`**。

-----

### 2\. Redis 資料儲存結構 (結果暫存/快取)

Redis 在此架構中作為一個高效能的 Key-Value 儲存，用於**暫存非同步任務的最終結果**。這種設計可以讓 Web App 快速輪詢 (polling) 查詢，而無需頻繁查詢主資料庫。

  - **結構**: Key-Value Store
  - **Key**: `task:{task_id}`
      - 使用 `task_id` (應為 `UUID`) 作為唯一的鍵。加上 `task:` 前綴是良好的實踐，可以避免鍵名衝突。
  - **Value**: `JSON String`
      - 值可以是一個 JSON 字串，儲存 AI Worker 處理完成的結果。
      - 範例:
        ```json
        {
          "status": "SUCCESS",
          "result_type": "tts_audio",
          "data": {
            "text_response": "這是您問題的答案。",
            "audio_output_url": "https://storage.googleapis.com/your-bucket/tts_output/xyz.mp3"
          },
          "error_message": null
        }
        ```
  - **生命週期 (TTL)**: 建議為每個 Key 設置一個合理的過期時間 (Time-To-Live)，例如 5-10 分鐘。這能確保 Redis 不會被過時的任務結果佔滿。當使用者成功獲取結果或超過時效後，資料會自動被清除。

-----

### 3\. Milvus 資料儲存結構 (RAG 向量資料庫)

Milvus 專為向量相似度搜尋而設計，是 RAG (Retrieval-Augmented Generation) 流程的核心。其資料儲存單位是 **Collection**，類似於 SQL 中的資料表。

  - **結構**: Collection
  - **Collection Name**: `rag_documents` (或依據知識庫領域命名)

一個 Collection 中會包含多個 **Fields**，以下為建議的欄位設計：

| 欄位名稱 (Field Name) | 資料型態 (Data Type) | 限制/說明 |
| :--- | :--- | :--- |
| `doc_id` | `INT64` | **Primary Key**。文件的唯一識別碼。 |
| `source_document_id`| `VARCHAR` | 原始文件的識別碼或檔名，用於追溯資料來源。 |
| `chunk_text` | `VARCHAR` | **原始文本區塊**。這是向量化前的文本片段，用於在檢索到相似向量後，將原始文本提供給 LLM 作為上下文。`max_length` 需根據模型限制設定。 |
| `text_vector` | `FLOAT_VECTOR` | **文本向量**。由 `chunk_text` 經過 Embedding Model 計算得出的向量表示。**這是 Milvus 搜尋的核心**。向量維度 (如 768 或 1024) 取決於所使用的模型。 |

開發者透過離線的 Python 腳本，將文件切塊 (Chunking)、向量化後，將上述結構的資料寫入 Milvus 的 `rag_documents` Collection 中，以供 LLM Service 在處理請求時進行高效的 RAG 檢索。
